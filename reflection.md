# Short Reflection
## What Did I Learn?
Through this Budget Tracker project, I deepened my understanding of Python fundamentals, particularly in object-oriented programming (OOP). I learned how to effectively use classes and inheritance by creating a base Transaction class and subclasses Income and Expense, utilizing super() to initialize inherited attributes. This helped me grasp encapsulation and how to group related attributes and methods logically. Additionally, I gained experience with collections like lists for storing transactions and dictionaries for summarizing category totals. Implementing functions for modularity taught me the importance of code reuse, avoiding repetition, and passing parameters/returning values efficiently. I also improved my skills in loops (for iteration over transactions) and conditionals (for menu navigation and input validation). Overall, the project reinforced how to structure a program with a main loop, handle user interactions gracefully, and apply robustness to prevent errors like invalid inputs or empty datasets.
## Challenges I Faced?
One major challenge was properly implementing inheritance without duplicating codeâ€”initially, I struggled with calling super() correctly in the subclasses, leading to attribute errors. Filtering transactions by month or category required careful string handling (e.g., using startswith for dates and lowercase comparisons), and I had to debug cases where filters returned no results unexpectedly. Input validation for amounts was tricky; converting strings to floats while handling exceptions and ensuring positivity took several iterations. Managing the program's flow without global variables and ensuring the BudgetTracker class encapsulated all operations also posed difficulties, as I had to refactor early versions that relied too heavily on procedural code. Finally, adding optional features like the undo function and threshold warnings required extra logic to avoid index errors on empty lists, testing my error-handling skills.
## How Do I Intend to Improve It, Given More Time?
With more time, I would enhance date validation using Python's datetime module to ensure valid YYYY-MM-DD formats and prevent invalid entries. I'd implement additional optional features, such as displaying top spending categories by sorting the dictionary values or adding basic unit tests with assertions to verify methods like show_summary(). Finally, I'd optimize performance for large transaction lists and add more robust error messages for edge cases, making the program even more user-friendly and scalable.
